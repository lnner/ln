2017/10/21
做搜索框时没有理解到：
想要一个DOM对象既float（或position）横排贴着另一个同样float（或定位）的DOM对象，又要width=100%，会导致宽度超出当前的浏览器窗口。
既要padding（margin）又要width=100%,也一样导致超出当前窗口。
解决方法：可以一个浮动另一个不浮动，然后不浮动的加个width=100%，由无100%的父元素padding（margin）挤出空间，使得看起来是刚好贴着就行。

2017/10/24（程序员节）
一个数整除另一个数在代码中是有浮点小数的，没有整除的结果，但可以通过parseInt()来忽略小数后面的得到想要的答案

对于10进制的数，想要获取十位数但数字太小，想要在前面加零时，可以通过parseInt(x/10)和x%10获取到想要的结果，例如02，多位数也同理得到

自动动画中的动画，例如轮播图，定时器加transition或animate，以这种方式做轮播图时要注意：
（看到的为1234）
1.实际最前和最后为相同的一张图片，即所看到的最后一张要加与第一张相同的图片;//12341

2.要是有索引器，在原本的最前面要加一张与所看到的最后一张相同的图片，即为实际倒数第二张；//412341

3.要是有手动滑动（移动端），在滑动时要先停止定时器，再进行判定和所要执行的动画，最后要再重新开始定时器

pc端，当页面缩到底，index又为确定值（例如index=5）,会跳过结束事件，产生bug，但移动端不会有问题。
解决方法：给个更大的范围，例如(index>=5)

2017/10/25
height:100%；当父元素无高度时，子元素（标准流）的高度100%也就不会起作用（但absolute还是能100%），例子: 
<html>
   <body>
	<div style='height:100%'></div>//无作用
   </body>
</html>
/*解决办法：给div的父元素加高度，但在这里的div有两个父元素，需要给html,body同时加height:100%;*/
/*margin和padding，元素height大于body和html的高度都会使页面出现滚动条*/
/*body相对于html，html相对于整个页面（浏览器的头部工具栏不是）*/

2017/10/30 
在给全局样式css定义个样式时，会给每个标签都加上该样式/注意媒体查询，它也是个全局/

2017/11/03
动态数据生成不能绑定事件，需要初始化
使用template插件不能在该script中注释

2017/11/04
dataset是js获取单个或多个存储在当前元素中的自定义属性(data-xxx)-它是一个dom属性

tap事件有一个bug,在zepto中，如果使用事件委托来绑定事件，在tap事件的时候有可能无法正确的绑定事件

location.href//整个网址
location.search//？后面的网址（包括问号）

2017/11/05
绑定事件时最好在on之前加off（事件，事件源）//jQ

在多次发生同一事件的情况下，使用append()时有可能导致多次添加

2017/11/07
使用template插件时，根据ajax输出值后，即使再通过ajax异步更改了后台的值，当前表面页面也不再发生改变，要改变可以通过css，js修改表面，又或者刷新页面重新输出值

2017/12/07
页面加载：Dom边加载边执行
页面初次渲染完成：Dom加载完成
页面显示：图片等等资源加载完成

2018/2/13
span是inline，input是inline-block
show会把原本行内标签转成inline-block
fadeIn，slideup变成原本的display


2018/2/25
$().index(),它是获取***同级***的元素的位置
text-align:justify，两边对齐

2018/2/26
给tr加上border属性是没有作用的，所有的border样式都由最外层的table和最内层的td,th来控制

2018/3/20
尽量别使用css的时间为0的hover和js的animate嵌套animate，触发过快或多次容易出现意想不到的效果(队列的问题)

2018/3/26
设置遮罩层的height为100%，它获取的是body的高度，但当窗口发生改变(出现滚动条)，body的高就变成页面标准流所占的高度，遮罩层还是保留该高度，所以需要使用resize事件监听窗口大小，并当发生改变时遮罩层保持整个页面（包含脱标）的高度---$(document).height()

2018/3/29
凡是inline都会线对齐，例如button以该value的文字对齐

2018/4/11
尽量为函数命名，有了函数名，可以很容易知道这段代码的作用，在控制台调试出错的时候，控制台会告诉你是哪个函数出错了，而不是一个匿名函数（anonymous）。可以让你把这些函数移动到合适的位置，使用的时候用函数名调用就可以了

2018/4/13
如果append之类的只添加一次dom元素，可以改为添加字符串形式的dom元素(但会失去绑定的事件和数据)，或者每次添加都先克隆clone一次最新的dom元素，因为只获取现有的子节点的话只是把现有的dom元素（子节点）再次移（剪贴）到父节点，所以没效果

2018/4/16
监听scroll时并不会很精确到每一1px，所以要预留误差

2018/4/22
vue有专门封装设置，可同时传入事件对象（event）和其它参数

2018/4/24
不能强制赋值给input的file

2018/4/28
vue引入iconfont.css时，当前文件夹还需要有字体文件eot,svg,ttf,woff等文件，所以请把整个文件夹移过去

2015/5/03
Google Chrome只支持在线网站的cookie的读写操作，对本地html的cookie操作是禁止的，在本地获取不到cookie。输出数据为空，必须在服务器上才可以。如果是本地的话，可以放到local的www目录下面。

2018/5/09
在DOM中，event对象只能作为仅有的参数传给事件处理程序,想要同时传入事件对象（event），可以多加一层函数，把该函数的事件对象作为唯一参数传入目标函数（子函数）内，目标函数，同时传入其它参数拟达到效果。
（ps：事件对象，ie是用window.event-- event = event?event:window.event）
缺点： 对事件处理函数包装后，移除事件的时候会变得麻烦。

2018/5/14
POST请求中URL需要编码吗？:
依赖于HTTP-HEADER中的“Content-Type”，如果是“application/x-www-form-urlencoded”，则需要编码，“multipart/form-data”不需要。

乱码产生的原因:
所有浏览器提供的AJAX对象请求参数默认使用 UTF-8 进行编码；而服务器端默认使用 ISO-8859-1 去解码，编码与解码方式不一致导致了乱码的产生。

总结：
浏览器端的AJAX对象默认编码方式为UTF-8,解码方式默认与服务器端的编码方式一致,而服务器端的默认编码和解码方式都为ISO-8859-1。所以如果浏览器端的编码方式和服务器端的解码方式不一样会产生乱码。
由于浏览器端的解码方式由服务器端的编码方式而定，所以浏览器与服务器的解码和编码方式是一致的，只需要他们的编解码方式支持中文就不会出现乱码的问题了。
注意：
UTF-8支持中文编码和解码方式，所以当服务器端和浏览器端都使用统一的编码和解码方式：UTF-8 ,即可解决中文乱码问题；由于 ISO-8859-1 本身并不支持中文的编码和解码，所以即使服务器端和浏览器端都使用统一的编码和解码方式：ISO-8859-1 也会产生中文乱码的问题。

2018/5/18
setTimeout()(或者其他函数)传递一个函数时,由于setTimeout()调用的代码运行在与所在函数是完全分离的执行环境上。这会导致这些代码中包含的 this关键字在非严格模式会指向 window (或全局)对象，严格模式下为 undefined，这和所期望的this的值是不一样的。
但当在setTimeout中传入的不是函数时，this则指向当前对象

2018/5/21
this跟函数在哪里定义无关，上下文才决定了this的引用

2018/6/22
非标准流要是设置为百分比跟随body的大小时，而外层body也为百分比，当窗口改变时被标准流不会跟着改变

2018/6/25
子级（无论是否脱标）设置了百分比时，当父级设置了高度则跟随父级，要是没有就跟随子级的内容高度

2018/7/5
想要点击不触发blur，可以用mousedown加event.preventDefault解决

2018/7/6
js控制宽高时尽量不用百分比，可能会立即触发

2018/7/13
js直接赋值input的value值并不会触发change事件
解决方法：可以手动触发

float和position的层级位置，不同浏览器不同位置
position层级的优先级：position先从同层级的pk（fixed,absolute,relative），若同级无position或position无定义z-index，则往下一层子元素pk，直到有设置position（fixed,absolute,relative为止，若pk后判断出层级优先级，则该位置的子元素们都遵循该优先级

2018/7/25
使用input，popertychange事件能很好获取input里的输入值
（oninput事件则支持FF/Opera/Safari/NetScape，onpopertychange事件只在IE下才有效）

2018/8/13
在使用canvas的canvas.getContext('2d')/ctx.drawImage时，指定尺寸值时绘制的图像的宽度和高度应该大于或等于1。如果宽度和/或高度为0，则会导致：

IndexSizeError: Index or size is negative or greater than the allowed amount


解决方法：
width = Math.max(1, Math.floor(width));
height = Math.max(1, Math.floor(height));
ctx.drawImage(image, x, y, width, height);


2018/10/18
new Promise会把一个对象指向缓存区，最终结果是promise结束后的最终值，若中途有深拷贝到另一个对象上，该对象值为当前值，不指向最后

2018/12/21
判断是否为ie：ie=!-[1,];

2019/2/21
 JavaScript中有三个可以对字符串编码的函数，分别是： escape,encodeURI,encodeURIComponent，相应3个解码函数：unescape,decodeURI,decodeURIComponent 。

escape()除了 ASCII 字母、数字和特定的符号外，对传进来的字符串全部进行转义编码，因此如果想对URL编码，最好不要使用此方法。而encodeURI() 用于编码整个URI,因为URI中的合法字符都不会被编码转换。encodeURIComponent方法在编码单个URIComponent（指请求参 数）应当是最常用的，它可以讲参数中的中文、特殊字符进行转义，而不会影响整个URL。

















